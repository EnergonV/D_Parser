
Everything that still needs to be handled by D_Parser comes right in here:

* UFCS -- assert("fdas" == "asdf".reverse()); and stuff -- very complex & time-intensive!
* CTFE
* Implement declaration condition checks
	- omit debug/versioned declarations 
	  if not fitting to environment dependencies
	  ([debug/release] or [Windows/Mac/Unix/BSD] etc.)
* Interface/Abstract class implementation

* Make Mixin analysis etc. multi-threaded!

Completion bugs:
* If module and type are named equally, a module must not be preferred!
* Disable completion on module statements/offer package identifiers
* Typing in D-IDE is often very slow.
* Check do ... while(); -- throws invalid error

=======================================

CTFE caching concept:

Store a tuple of input values and the returned value.
->	Calculate hash sum of a method.


Mixin caching:

mixin("some A"~cnstA~ctfeSomeThing(23,T));

- Inter-parsing caching:
	->	Calculate a hash of the mixed-in expression
	Store Mixin Hash => 
		[ParsedStatement/ParsedAst, 
		Executed CTFE functions (method hash; arg hashes are included in the mixin hash already)]

- Avoid re-analyzing mixins during one resolution (including sub-resolutions):
->	Store a tuple of the template parameters (param name => param node) which were introduced 
	in the res context (so far until PrevContextIsInSameHierarchy is false) 
	and the actual mixin string/ast/blockstatement
->	Reuse the mixin if all template parameters do match

- Parsing the mixin string is fast:
- It's needed to cache the mixin string then
- Optimize string concatination --- Pass string builder instance between concat operations?

Evaluation caching:
	While evaluating an expression,
		store all accessed symbols and the hash of the e 

=======================================

* Pre-resolve constant values (such as const/enum literals) from least to most dependent(?)
* Handle semantic errors that occur during analysis/resolution/evaluation etc. -> Implement own Exceptions for that!

Resolver:
	- .tupleof for structs
	- .offsetof for struct fields
	- new MyClass() should return the ctor member instead - that has the actual class as its return type
	- Handle argument-parameter match

Template parameter deduction:
 - Handle __FILE__ and __LINE__ correctly concerning template values

 Tests:
  - Find out what features did change after it added the first expression as ResultBase to UFCS results


  Expression evaluation:
  - CTFE
  - Assign expressions
  - Identity expression
  - Operator overloads
  - Finish equal expressions (pointer/object comparison)
  - Implement class/struct/pointer values
  - Complex numbers (on at least shift operators)
  - Handle >> and >>> correctly
  - InExpressions
  - NewExpressions in PostfixExpression_Access expressions
  - Implement static property resolution/evaluation
  - Pointer arrays in Index[/Slice] expressions